#!/bin/bash
set -e

# Git Subtree Manager
# A generic script to manage git subtrees across any repository
# Supports pulling subdirectories from remote repos (not just entire repos)
#
# Place this in your ~/bin and use it from any git repo
#
# Usage:
#   git-subtree-mgr add --prefix=PATH --repo=OWNER/REPO [--branch=BRANCH] [--path=PATH]
#   git-subtree-mgr pull [PREFIX]
#   git-subtree-mgr list

CONFIG_FILE=".github/.gitsubtrees"
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/git-subtree-mgr"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

info() { echo -e "${GREEN}==>${NC} $1"; }
warn() { echo -e "${YELLOW}==>${NC} $1"; }
error() { echo -e "${RED}==>${NC} $1"; exit 1; }
dim() { echo -e "${CYAN}$1${NC}"; }

usage() {
    cat <<EOF
Git Subtree Manager

Usage: $(basename "$0") <command> [options]

Commands:
  add     Add a new subtree to the project
  pull    Pull updates for configured subtrees
  list    List all configured subtrees

Add Options:
  --prefix=PATH      Local directory to place the subtree (required)
  --repo=OWNER/REPO  GitHub repository (or full URL) (required)
  --branch=BRANCH    Remote branch (default: main)
  --path=PATH        Path within remote repo to extract (default: entire repo)
  --no-squash        Preserve full history (default: squash)

Pull Options:
  [PREFIX]           Pull specific subtree (default: all)
  --no-squash        Preserve full history (default: squash)

Examples:
  # Add entire repo as subtree
  $(basename "$0") add --prefix=vendor/lib --repo=someone/lib

  # Add only a subdirectory from the repo
  $(basename "$0") add --prefix=.claude/agents --repo=rrlamichhane/claude-agents --path=.claude/agents

  # Pull updates
  $(basename "$0") pull
  $(basename "$0") pull .claude/agents
EOF
    exit 1
}

# Check if git subtree is available
check_subtree() {
    if ! git subtree --help > /dev/null 2>&1; then
        error "git subtree is not installed. Install it with:
  Ubuntu/Debian: sudo apt install git-subtree
  Fedora/RHEL:   sudo dnf install git-subtree
  macOS:         brew reinstall git"
    fi
}

# Ensure we're in a git repo and cd to root
check_git() {
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        error "Not inside a git repository"
    fi
    cd "$(git rev-parse --show-toplevel)"
}

# Expand repo shorthand to full URL
expand_repo_url() {
    local repo="$1"
    if [[ "$repo" =~ ^https?:// ]] || [[ "$repo" =~ ^git@ ]]; then
        echo "$repo"
    else
        echo "https://github.com/$repo"
    fi
}

# Generate a cache key from repo URL
repo_cache_key() {
    local repo="$1"
    echo "$repo" | sed 's/[^a-zA-Z0-9]/_/g'
}

# Clone or update a repo in the cache directory
# Returns the path to the cached repo
cache_repo() {
    local remote_url="$1"
    local branch="$2"
    local cache_key
    cache_key=$(repo_cache_key "$remote_url")
    local cache_path="$CACHE_DIR/$cache_key"

    mkdir -p "$CACHE_DIR"

    if [[ -d "$cache_path/.git" ]]; then
        # Update existing cache
        info "Updating cached repo..." >&2
        (cd "$cache_path" && git fetch origin "$branch" && git checkout -f "origin/$branch") > /dev/null 2>&1
    else
        # Clone fresh
        info "Cloning repository..." >&2
        rm -rf "$cache_path"
        git clone --single-branch --branch "$branch" "$remote_url" "$cache_path" > /dev/null 2>&1
    fi

    echo "$cache_path"
}

# Split a subdirectory from a repo into a branch
# This creates a branch containing only the history of that subdirectory
split_subdir() {
    local repo_path="$1"
    local subdir="$2"
    local split_branch="split-$$"

    (
        cd "$repo_path" || exit 1
        # Check if the path exists
        if [[ ! -d "$subdir" ]]; then
            echo "ERROR: Path '$subdir' does not exist in the repository" >&2
            exit 1
        fi
        # Clean up any existing split branch from previous runs
        git branch -D "$split_branch" 2>/dev/null || true
        # Create split branch with only the subdirectory
        if ! git subtree split --prefix="$subdir" -b "$split_branch" >&2; then
            echo "ERROR: git subtree split failed" >&2
            exit 1
        fi
        echo "$split_branch"
    )
}

# Read config file into arrays
read_config() {
    PREFIXES=()
    REMOTES=()
    BRANCHES=()
    PATHS=()

    if [[ ! -f "$CONFIG_FILE" ]]; then
        return
    fi

    while IFS='|' read -r prefix remote branch path || [[ -n "$prefix" ]]; do
        # Skip comments and empty lines
        [[ "$prefix" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$prefix" ]] && continue

        # Trim whitespace
        prefix=$(echo "$prefix" | xargs)
        remote=$(echo "$remote" | xargs)
        branch=$(echo "$branch" | xargs)
        path=$(echo "$path" | xargs)

        PREFIXES+=("$prefix")
        REMOTES+=("$remote")
        BRANCHES+=("$branch")
        PATHS+=("$path")
    done < "$CONFIG_FILE"
}

# Add entry to config file
add_to_config() {
    local prefix="$1"
    local remote="$2"
    local branch="$3"
    local path="$4"

    mkdir -p "$(dirname "$CONFIG_FILE")"

    # Create file with header if it doesn't exist
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" <<EOF
# Git Subtrees Configuration
# Format: prefix | remote | branch | remote-path
# Managed by git-subtree-mgr
#
EOF
    fi

    echo "$prefix | $remote | $branch | $path" >> "$CONFIG_FILE"
}

# Check if prefix already exists in config
prefix_exists() {
    local check_prefix="$1"
    read_config
    for prefix in "${PREFIXES[@]}"; do
        if [[ "$prefix" == "$check_prefix" ]]; then
            return 0
        fi
    done
    return 1
}

# Find index of prefix in config
find_prefix_index() {
    local check_prefix="$1"
    for i in "${!PREFIXES[@]}"; do
        if [[ "${PREFIXES[$i]}" == "$check_prefix" ]]; then
            echo "$i"
            return 0
        fi
    done
    return 1
}

# Clean up split branches from cached repo
cleanup_split() {
    local repo_path="$1"
    local split_branch="$2"
    if [[ -n "$split_branch" ]] && [[ -d "$repo_path/.git" ]]; then
        (cd "$repo_path" && git branch -D "$split_branch" 2>/dev/null) || true
    fi
}

cmd_add() {
    local prefix=""
    local repo=""
    local branch="main"
    local path="."
    local squash="--squash"

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --prefix=*) prefix="${arg#*=}" ;;
            --repo=*) repo="${arg#*=}" ;;
            --branch=*) branch="${arg#*=}" ;;
            --path=*) path="${arg#*=}" ;;
            --no-squash) squash="" ;;
            *) error "Unknown option: $arg" ;;
        esac
    done

    # Validate required args
    [[ -z "$prefix" ]] && error "Missing required option: --prefix"
    [[ -z "$repo" ]] && error "Missing required option: --repo"

    check_git
    check_subtree

    # Save original directory
    local orig_dir
    orig_dir=$(pwd)

    # Check if already configured
    if prefix_exists "$prefix"; then
        error "Subtree '$prefix' is already configured. Use 'pull' to update."
    fi

    # Check if directory already exists
    if [[ -d "$prefix" ]] && [[ "$(ls -A "$prefix" 2>/dev/null)" ]]; then
        error "Directory '$prefix' already exists and is not empty"
    fi

    local remote_url
    remote_url=$(expand_repo_url "$repo")

    info "Adding subtree: $prefix"
    dim "  Remote: $remote_url"
    dim "  Branch: $branch"
    dim "  Path:   $path"
    echo ""

    local split_branch=""
    local cache_path=""

    if [[ "$path" != "." ]]; then
        # Need to extract a subdirectory
        cache_path=$(cache_repo "$remote_url" "$branch")

        info "Extracting subdirectory: $path"
        split_branch=$(split_subdir "$cache_path" "$path")

        if [[ -z "$split_branch" ]]; then
            error "Failed to split subdirectory '$path'"
        fi

        # Add the cached repo as a temporary remote
        local temp_remote="subtree-temp-$$"
        git remote remove "$temp_remote" 2>/dev/null || true
        git remote add "$temp_remote" "$cache_path"

        if ! git fetch "$temp_remote" "$split_branch"; then
            git remote remove "$temp_remote" 2>/dev/null || true
            cleanup_split "$cache_path" "$split_branch"
            error "Failed to fetch split branch"
        fi

        # Add the subtree from the split branch
        # shellcheck disable=SC2086
        if ! git subtree add --prefix="$prefix" $squash "$temp_remote/$split_branch"; then
            git remote remove "$temp_remote" 2>/dev/null || true
            cleanup_split "$cache_path" "$split_branch"
            error "Failed to add subtree"
        fi

        # Cleanup
        git remote remove "$temp_remote" 2>/dev/null || true
        cleanup_split "$cache_path" "$split_branch"
    else
        # Simple case: add entire repo
        # shellcheck disable=SC2086
        git subtree add --prefix="$prefix" $squash "$remote_url" "$branch"
    fi

    # Add to config
    add_to_config "$prefix" "$repo" "$branch" "$path"
    git add "$CONFIG_FILE"

    info "Subtree added successfully!"
    echo ""
    echo "Next steps:"
    echo "  git status                  # review changes"
    echo "  git commit -m 'Add $prefix subtree'"
}

cmd_pull() {
    local target_prefix=""
    local squash="--squash"

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --no-squash) squash="" ;;
            -*) error "Unknown option: $arg" ;;
            *) target_prefix="$arg" ;;
        esac
    done

    check_git
    check_subtree
    read_config

    if [[ ${#PREFIXES[@]} -eq 0 ]]; then
        error "No subtrees configured. Use 'add' first."
    fi

    # If specific prefix requested, validate it exists
    if [[ -n "$target_prefix" ]]; then
        if ! find_prefix_index "$target_prefix" > /dev/null; then
            error "Subtree '$target_prefix' not found in config"
        fi
    fi

    local pulled=0
    local failed=0

    for i in "${!PREFIXES[@]}"; do
        local prefix="${PREFIXES[$i]}"
        local repo="${REMOTES[$i]}"
        local branch="${BRANCHES[$i]}"
        local path="${PATHS[$i]}"

        # Skip if targeting specific prefix
        if [[ -n "$target_prefix" ]] && [[ "$prefix" != "$target_prefix" ]]; then
            continue
        fi

        local remote_url
        remote_url=$(expand_repo_url "$repo")

        info "Pulling: $prefix"
        dim "  From: $remote_url ($branch)"
        if [[ "$path" != "." ]]; then
            dim "  Path: $path"
        fi

        local split_branch=""
        local cache_path=""
        local pull_success=false

        if [[ "$path" != "." ]]; then
            # Need to extract subdirectory
            cache_path=$(cache_repo "$remote_url" "$branch")
            split_branch=$(split_subdir "$cache_path" "$path")

            if [[ -z "$split_branch" ]]; then
                warn "Failed to split subdirectory '$path'"
                ((++failed))
                continue
            fi

            # Add temp remote and pull
            local temp_remote="subtree-temp-$$"
            git remote remove "$temp_remote" 2>/dev/null || true
            git remote add "$temp_remote" "$cache_path"

            if ! git fetch "$temp_remote" "$split_branch"; then
                warn "Failed to fetch split branch"
                git remote remove "$temp_remote" 2>/dev/null || true
                cleanup_split "$cache_path" "$split_branch"
                ((++failed))
                continue
            fi

            # shellcheck disable=SC2086
            if git subtree pull --prefix="$prefix" $squash "$temp_remote" "$split_branch" -m "Update $prefix subtree"; then
                pull_success=true
            fi

            # Cleanup
            git remote remove "$temp_remote" 2>/dev/null || true
            cleanup_split "$cache_path" "$split_branch"
        else
            # Simple case: pull entire repo
            # shellcheck disable=SC2086
            if git subtree pull --prefix="$prefix" $squash "$remote_url" "$branch" -m "Update $prefix subtree"; then
                pull_success=true
            fi
        fi

        if $pull_success; then
            ((++pulled))
        else
            warn "Failed to pull $prefix"
            ((++failed))
        fi
        echo ""
    done

    if [[ $pulled -gt 0 ]]; then
        info "Pulled $pulled subtree(s)"
    fi
    if [[ $failed -gt 0 ]]; then
        warn "$failed subtree(s) failed"
        exit 1
    fi
}

cmd_list() {
    check_git
    check_subtree
    read_config

    if [[ ${#PREFIXES[@]} -eq 0 ]]; then
        echo "No subtrees configured."
        echo ""
        echo "Add one with:"
        echo "  $(basename "$0") add --prefix=PATH --repo=OWNER/REPO"
        exit 0
    fi

    echo "Configured subtrees:"
    echo ""
    printf "  ${CYAN}%-25s${NC} %-35s %-10s %s\n" "PREFIX" "REPOSITORY" "BRANCH" "PATH"
    echo "  $(printf '%.0s-' {1..95})"

    for i in "${!PREFIXES[@]}"; do
        local path_display="${PATHS[$i]}"
        [[ "$path_display" == "." ]] && path_display="(entire repo)"
        printf "  %-25s %-35s %-10s %s\n" "${PREFIXES[$i]}" "${REMOTES[$i]}" "${BRANCHES[$i]}" "$path_display"
    done
    echo ""
}

# Main
case "${1:-}" in
    add)
        shift
        cmd_add "$@"
        ;;
    pull)
        shift
        cmd_pull "$@"
        ;;
    list)
        cmd_list
        ;;
    -h|--help|help)
        usage
        ;;
    *)
        usage
        ;;
esac
