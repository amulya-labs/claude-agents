#!/bin/bash
set -e

# Git Subtree Manager
# A generic script to manage git subtrees across any repository
#
# Place this in your ~/bin and use it from any git repo
#
# Usage:
#   git-subtree-mgr add --prefix=PATH --repo=OWNER/REPO [--branch=BRANCH] [--path=PATH]
#   git-subtree-mgr pull [PREFIX]
#   git-subtree-mgr list

CONFIG_FILE=".github/.gitsubtrees"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

info() { echo -e "${GREEN}==>${NC} $1"; }
warn() { echo -e "${YELLOW}==>${NC} $1"; }
error() { echo -e "${RED}==>${NC} $1"; exit 1; }
dim() { echo -e "${CYAN}$1${NC}"; }

usage() {
    cat <<EOF
Git Subtree Manager

Usage: $(basename "$0") <command> [options]

Commands:
  add     Add a new subtree to the project
  pull    Pull updates for configured subtrees
  list    List all configured subtrees

Add Options:
  --prefix=PATH      Local directory to place the subtree (required)
  --repo=OWNER/REPO  GitHub repository (or full URL) (required)
  --branch=BRANCH    Remote branch (default: main)
  --path=PATH        Path within remote repo (default: root)
  --no-squash        Preserve full history (default: squash)

Pull Options:
  [PREFIX]           Pull specific subtree (default: all)
  --no-squash        Preserve full history (default: squash)

Examples:
  $(basename "$0") add --prefix=.claude/agents --repo=rrlamichhane/claude-agents --path=.claude/agents
  $(basename "$0") pull
  $(basename "$0") pull .claude/agents
EOF
    exit 1
}

# Ensure we're in a git repo and cd to root
check_git() {
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        error "Not inside a git repository"
    fi
    cd "$(git rev-parse --show-toplevel)"
}

# Expand repo shorthand to full URL
expand_repo_url() {
    local repo="$1"
    if [[ "$repo" =~ ^https?:// ]] || [[ "$repo" =~ ^git@ ]]; then
        echo "$repo"
    else
        echo "https://github.com/$repo"
    fi
}

# Read config file into arrays
read_config() {
    PREFIXES=()
    REMOTES=()
    BRANCHES=()
    PATHS=()

    if [[ ! -f "$CONFIG_FILE" ]]; then
        return
    fi

    while IFS='|' read -r prefix remote branch path || [[ -n "$prefix" ]]; do
        # Skip comments and empty lines
        [[ "$prefix" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$prefix" ]] && continue

        # Trim whitespace
        prefix=$(echo "$prefix" | xargs)
        remote=$(echo "$remote" | xargs)
        branch=$(echo "$branch" | xargs)
        path=$(echo "$path" | xargs)

        PREFIXES+=("$prefix")
        REMOTES+=("$remote")
        BRANCHES+=("$branch")
        PATHS+=("$path")
    done < "$CONFIG_FILE"
}

# Add entry to config file
add_to_config() {
    local prefix="$1"
    local remote="$2"
    local branch="$3"
    local path="$4"

    mkdir -p "$(dirname "$CONFIG_FILE")"

    # Create file with header if it doesn't exist
    if [[ ! -f "$CONFIG_FILE" ]]; then
        cat > "$CONFIG_FILE" <<EOF
# Git Subtrees Configuration
# Format: prefix | remote | branch | remote-path
# Managed by git-subtree-mgr
#
EOF
    fi

    echo "$prefix | $remote | $branch | $path" >> "$CONFIG_FILE"
}

# Check if prefix already exists in config
prefix_exists() {
    local check_prefix="$1"
    read_config
    for prefix in "${PREFIXES[@]}"; do
        if [[ "$prefix" == "$check_prefix" ]]; then
            return 0
        fi
    done
    return 1
}

# Find index of prefix in config
find_prefix_index() {
    local check_prefix="$1"
    for i in "${!PREFIXES[@]}"; do
        if [[ "${PREFIXES[$i]}" == "$check_prefix" ]]; then
            echo "$i"
            return 0
        fi
    done
    return 1
}

cmd_add() {
    local prefix=""
    local repo=""
    local branch="main"
    local path=""
    local squash="--squash"

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --prefix=*) prefix="${arg#*=}" ;;
            --repo=*) repo="${arg#*=}" ;;
            --branch=*) branch="${arg#*=}" ;;
            --path=*) path="${arg#*=}" ;;
            --no-squash) squash="" ;;
            *) error "Unknown option: $arg" ;;
        esac
    done

    # Validate required args
    [[ -z "$prefix" ]] && error "Missing required option: --prefix"
    [[ -z "$repo" ]] && error "Missing required option: --repo"

    # Default path to root if not specified
    [[ -z "$path" ]] && path="."

    check_git

    # Check if already configured
    if prefix_exists "$prefix"; then
        error "Subtree '$prefix' is already configured. Use 'pull' to update."
    fi

    # Check if directory already exists
    if [[ -d "$prefix" ]] && [[ "$(ls -A "$prefix" 2>/dev/null)" ]]; then
        error "Directory '$prefix' already exists and is not empty"
    fi

    local remote_url
    remote_url=$(expand_repo_url "$repo")

    info "Adding subtree: $prefix"
    dim "  Remote: $remote_url"
    dim "  Branch: $branch"
    dim "  Path:   $path"
    echo ""

    # For subtree split from remote, we need to fetch and filter
    if [[ "$path" != "." ]]; then
        # Create a temporary remote
        local temp_remote="subtree-temp-$$"
        git remote add "$temp_remote" "$remote_url" 2>/dev/null || true
        git fetch "$temp_remote" "$branch"

        # Use subtree add with the fetched ref
        # shellcheck disable=SC2086
        git subtree add --prefix="$prefix" $squash "$temp_remote/$branch"

        # If we only want a subpath, we need a different approach
        # git subtree doesn't support remote subpaths directly
        # We'll note this limitation and pull the whole thing
        if [[ "$path" != "." ]]; then
            warn "Note: git subtree pulls entire repo. Path '$path' stored for reference."
        fi

        git remote remove "$temp_remote"
    else
        # Simple case: add entire repo
        # shellcheck disable=SC2086
        git subtree add --prefix="$prefix" $squash "$remote_url" "$branch"
    fi

    # Add to config
    add_to_config "$prefix" "$repo" "$branch" "$path"
    git add "$CONFIG_FILE"

    info "Subtree added successfully!"
    echo ""
    echo "Next steps:"
    echo "  git status                  # review changes"
    echo "  git commit -m 'Add $prefix subtree'"
}

cmd_pull() {
    local target_prefix=""
    local squash="--squash"

    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --no-squash) squash="" ;;
            -*) error "Unknown option: $arg" ;;
            *) target_prefix="$arg" ;;
        esac
    done

    check_git
    read_config

    if [[ ${#PREFIXES[@]} -eq 0 ]]; then
        error "No subtrees configured. Use 'add' first."
    fi

    # If specific prefix requested, validate it exists
    if [[ -n "$target_prefix" ]]; then
        if ! find_prefix_index "$target_prefix" > /dev/null; then
            error "Subtree '$target_prefix' not found in config"
        fi
    fi

    local pulled=0
    local failed=0

    for i in "${!PREFIXES[@]}"; do
        local prefix="${PREFIXES[$i]}"
        local repo="${REMOTES[$i]}"
        local branch="${BRANCHES[$i]}"

        # Skip if targeting specific prefix
        if [[ -n "$target_prefix" ]] && [[ "$prefix" != "$target_prefix" ]]; then
            continue
        fi

        local remote_url
        remote_url=$(expand_repo_url "$repo")

        info "Pulling: $prefix"
        dim "  From: $remote_url ($branch)"

        # shellcheck disable=SC2086
        if git subtree pull --prefix="$prefix" $squash "$remote_url" "$branch" -m "Update $prefix subtree"; then
            ((++pulled))
        else
            warn "Failed to pull $prefix"
            ((++failed))
        fi
        echo ""
    done

    if [[ $pulled -gt 0 ]]; then
        info "Pulled $pulled subtree(s)"
    fi
    if [[ $failed -gt 0 ]]; then
        warn "$failed subtree(s) failed"
        exit 1
    fi
}

cmd_list() {
    check_git
    read_config

    if [[ ${#PREFIXES[@]} -eq 0 ]]; then
        echo "No subtrees configured."
        echo ""
        echo "Add one with:"
        echo "  $(basename "$0") add --prefix=PATH --repo=OWNER/REPO"
        exit 0
    fi

    echo "Configured subtrees:"
    echo ""
    printf "  ${CYAN}%-30s${NC} %-40s %s\n" "PREFIX" "REPOSITORY" "BRANCH"
    echo "  $(printf '%.0s-' {1..90})"

    for i in "${!PREFIXES[@]}"; do
        printf "  %-30s %-40s %s\n" "${PREFIXES[$i]}" "${REMOTES[$i]}" "${BRANCHES[$i]}"
    done
    echo ""
}

# Main
case "${1:-}" in
    add)
        shift
        cmd_add "$@"
        ;;
    pull)
        shift
        cmd_pull "$@"
        ;;
    list)
        cmd_list
        ;;
    -h|--help|help)
        usage
        ;;
    *)
        usage
        ;;
esac
